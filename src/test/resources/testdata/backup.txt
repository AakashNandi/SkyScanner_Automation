
//Flight homepage:

//package windows;
//
//import base.BasePage;
//import hooks.Hooks;
//import org.openqa.selenium.*;
//import org.openqa.selenium.support.FindBy;
//import org.openqa.selenium.support.ui.ExpectedCondition;
//import org.openqa.selenium.support.ui.ExpectedConditions;
//import org.openqa.selenium.support.ui.WebDriverWait;
//import utilities.WaitUtils;
//
//import java.time.Duration;
//import java.util.List;
//
//public class FlightHomePage extends BasePage {
//
//    private WaitUtils wait;
//
//    public FlightHomePage() {
//        super(Hooks.driver);
//        wait = new WaitUtils(Hooks.driver);
//    }
//
//    //Homepage loaded
//    @FindBy(xpath = "//button[@role='tab']")
//    WebElement home;
//
//    // Trip type dropdown
//    @FindBy(xpath = "//select[contains(@class,'flight_way')]")
//    WebElement tripTypeDropdown;
//
//    // Trip type options
//    @FindBy(xpath = "//select[contains(@class,'flight_way')]/option")
//    List<WebElement> tripTypeOptions;
//
//    // class type dropdown
//    @FindBy(xpath = "//select[@id='flight_type']")
//    WebElement classTypeDropdown;
//
//    // class type options
//    @FindBy(xpath = "//select[@id='flight_type']/option")
//    List<WebElement> classTypeOptions;
//
//
//    // From input
//    @FindBy(xpath = "//input[@name='from']")
//    WebElement fromInput;
//
//  //  @FindBy(xpath = "//div[@id='onereturn']")
//    @FindBy(xpath = "//div[@id='onereturn']/div[1]/div/div")
//    WebElement airportResultsContainer;
//
//
//    // To input
//    @FindBy(xpath = "//input[@name='to']")
//    WebElement toInput;
//
//    // Departure date button
//    @FindBy(id = "departure")
//    WebElement departureDateele;
//
//    // Return date button
//    @FindBy(id = "return_date")
//    WebElement returnDateele;
//
//    // Travellers button
//    @FindBy(xpath = "//a[@data-toggle='dropdown']")
//    WebElement travellersBtn;
//
////    // Travellers dropdown
////    @FindBy(xpath = "//div[contains(@class,'dropdown')]/div")
////    WebElement travellersdrop;
//
////    @FindBy(xpath = "//*[@id='fadults']")
////    WebElement adultCountTextLocator;
//
//    @FindBy(xpath = "(//div[input[@id='fadults']])[1]//ancestor::div[contains(@class, 'qtyBtn')]//div[@class='qtyInc']")
//    WebElement adultSectionElement;
//
////    @FindBy(xpath = "//*[@id='fchilds']")
////    WebElement childCountTextLocator;
//
//    @FindBy(xpath = "(//div[input[@id='fchilds']])[1]//ancestor::div[contains(@class, 'qtyBtn')]//div[@class='qtyInc']")
//    WebElement childSectionElement;
//
////    @FindBy(xpath = "//*[@id='finfant']")
////    WebElement infantCountTextLocator;
//
//    @FindBy(xpath = "(//div[input[@id='finfant']])[1]//ancestor::div[contains(@class, 'qtyBtn')]//div[@class='qtyInc']")
//    WebElement infantSectionElement;
//
//    // Search button
//    @FindBy(xpath = "//button[@id='flights-search']")
//    WebElement searchBtn;
//
////    @FindBy(id = "cookie_disclaimer")
////    WebElement popup;
//
//    // ========================= VERIFICATION ========================= //
//
//    public void verifyHomeLoaded() {
//        //wait.waitForVisible(By.xpath("//button[@role='tab']"));
//        //WaitUtils.dismissBottomPopupIfPresent(By.id("cookie_disclaimer"), By.id("cookie_stop"));
//
//       // WaitUtils.waitForInVisible(popup);
//        wait.waitForVisible(home);
//        System.out.println("Flight Home Page Loaded Successfully");
//    }
//
//    //action methods...................
//
//    public void selectTripType(String type) {
//        wait.waitForClickable(tripTypeDropdown).click();
//
//        for (WebElement option : tripTypeOptions) {
//            String text = option.getText().trim();
//            if (text.equalsIgnoreCase(type)) {
//                option.click();
//                break;
//            }
//        }
//    }
//
//
//    public void selectClassType(String cabinClass) {
//        wait.waitForClickable(classTypeDropdown).click();
//
//        for (WebElement option : classTypeOptions) {
//            String text = option.getText().trim();
//            if (text.equalsIgnoreCase(cabinClass)) {
//                option.click();
//                break;
//            }
//        }
//
//    }
//
//    public void enterFrom(String from, String code_f) {
//
//                fromInput.clear();
//
//                WebDriverWait wait = new WebDriverWait(driver, Duration.ofMillis(500)); // Set explicit wait time
//                // Slow typing: Send each character with an explicit wait for each character typed
//                for (char c : from.toCharArray()) {
//                    fromInput.sendKeys(String.valueOf(c));  // Send one character at a time
//
//                    // Wait for the input field value to update (waiting for it to change)
//                    wait.until(new ExpectedCondition<Boolean>() {
//                        public Boolean apply(WebDriver driver) {
//                            // Check if the value of the input field has changed (indicating a new character was typed)
//                            String currentText = fromInput.getAttribute("value");
//                            return currentText.length() > 0 && currentText.length() == fromInput.getAttribute("value").length();
//                            //The line ensures that the input field is not empty and that its value has been updated with the typed character.
//                            // It returns true if both conditions are satisfied, signaling that the typing action is complete.
//                        }
//                    });
//                }
//
//                By resultButtonLocator = By.xpath(String.format("//button[contains(text(),'%s')]", code_f));
//
//                WebElement select = WaitUtils.waitForPresence(resultButtonLocator);
//
//                WaitUtils.waitForVisible(select);
//
//                WaitUtils.waitForClickable(select);
//
//                WaitUtils.scrollIntoViewCenter(select);
//
//                select.click();
//
//             }
//
//
//    public void enterTo(String to, String code_t) {
//        //WaitUtils.dismissBottomPopupIfPresent(By.id("cookie_disclaimer"), By.id("cookie_stop"));
//
//        toInput.clear();
//
//        WebDriverWait wait = new WebDriverWait(driver, Duration.ofMillis(500));
//        for (char c : to.toCharArray()) {
//            toInput.sendKeys(String.valueOf(c));  // Send one character at a time
//
//            wait.until(new ExpectedCondition<Boolean>() {
//                public Boolean apply(WebDriver driver) {
//                    String currentText = toInput.getAttribute("value");
//                    return currentText.length() > 0 && currentText.length() == toInput.getAttribute("value").length();
//                }
//            });
//        }
//
//        By resultButtonLocator = By.xpath(String.format("//button[contains(text(),'%s')]", code_t));
//
//        WebElement select = WaitUtils.waitForPresence(resultButtonLocator);
//
//        WaitUtils.waitForVisible(select);
//
//        WaitUtils.waitForClickable(select);
//
//        WaitUtils.scrollIntoViewCenter(select);
//
//        select.click();
//
//    }
//
//    public void selectDepartureDate(String departureDate) {
//
//        WaitUtils.waitForClickable(departureDateele);
//
//        departureDateele.clear();
//
//        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(50));
//
//        for (char c : departureDate.toCharArray()) {
//
//            departureDateele.sendKeys(String.valueOf(c));
//
//            String finalDepartureDate = departureDate;
//            wait.until(driver -> {
//
//                String updatedValue = departureDateele.getAttribute("value");
//
//                return updatedValue.length() > 0 && !updatedValue.equals(finalDepartureDate);
//            });
//
//            departureDate = departureDateele.getAttribute("value");
//        }
//    }
//
//
//
//    public void selectDates(String departureDate, String returnDate) {
//        // Select departure date
//        selectDate(departureDateele, departureDate);
//
//        // Select return date (for multi-way)
//        selectDate(returnDateele, returnDate);
//    }
//
//    private void selectDate(WebElement dateElement, String date) {
//        WaitUtils.waitForClickable(dateElement);
//
//        dateElement.clear();
//
//        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(50));
//
//        for (char c : date.toCharArray()) {
//            dateElement.sendKeys(String.valueOf(c));
//
//            String finalDate = date;
//            wait.until(driver -> {
//                String updatedValue = dateElement.getAttribute("value");
//                return !updatedValue.equals(finalDate);
//            });
//
//            // Update the date to the latest value after each keypress
//            date = dateElement.getAttribute("value");
//            //This ensures that the date variable always reflects the most recent value that has been entered,
//            // which is helpful for the next iteration of the loop, where the program is waiting for the field to be updated.
//        }
//    }
//
//public void selectTravellers(String adultCount, String childCount, String infantCount) {
//
//    int aC = Integer.parseInt(adultCount);
//    int cC = Integer.parseInt(childCount);
//    int iC = Integer.parseInt(infantCount);
//
//    WaitUtils.waitForClickable(travellersBtn);
//    travellersBtn.click();
//
//    // Adjust the adult count
//    WaitUtils.waitForClickable(adultSectionElement);
//    adjustCount(aC, adultSectionElement);
//
//    WaitUtils.waitForClickable(childSectionElement);
//    // Adjust the child count
//    adjustCount(cC, childSectionElement);
//
//    WaitUtils.waitForClickable(infantSectionElement);
//    // Adjust the infant count
//    adjustCount(iC, infantSectionElement);
//}
//
//    private void adjustCount(int targetCount, WebElement sectionElement) {
//        // Default value based on the section element
//        int defaultCount = 0; // Default for child and infant
//        if (sectionElement.equals(adultSectionElement)) {
//            defaultCount = 1; // Default for adult is 1
//        }
//
//        // Calculate the number of clicks needed
//        int clicksRequired = targetCount - defaultCount;
//
//        // If no clicks are needed, return early
//        if (clicksRequired <= 0) return;
//
//
//        // Wait until the increment button is clickable
//        //WebDriverWait wait = new WebDriverWait(driver,  Duration.ofSeconds(10)); // 10 seconds max wait
////        WebElement incrementButton = sectionElement.findElement(By.cssSelector(".increment-button")); // Adjust this selector
//
//        JavascriptExecutor jsExecutor = (JavascriptExecutor) driver;
//        for (int i = 0; i < clicksRequired; i++) {
//            // Wait for the increment button to become clickable before clicking
//            //wait.until(ExpectedConditions.elementToBeClickable(incrementButton));
//            WaitUtils.waitForClickable(sectionElement);
//            // Click the increment button
//          //  sectionElement.click();
//            jsExecutor.executeScript("arguments[0].click();", sectionElement);
//            //WaitUtils.waitForClickable(sectionElement);
//
//            jsExecutor.executeScript("setTimeout(function(){}, 500);");
//            // Explicit wait for a minimal delay (500ms)
//            WaitUtils.waitForClickable(sectionElement); // Ensure the state of the element has changed before next click
//        }
//    }
//
//    public void clickSearch() {
//        WaitUtils.waitForClickable(searchBtn);
//        searchBtn.click();
//    }
//}


---------------------------------------------------------------------------------------------------------

//    public void selectTravellers(String adultCount, String childCount, String infantCount) {
//
//        int aC = Integer.parseInt(adultCount);
//        int cC = Integer.parseInt(childCount);
//        int iC = Integer.parseInt(infantCount);
//
//        // Step 1: Click on the travelers section to expand the dropdown
//        WaitUtils.waitForClickable(travellersBtn);
//        travellersBtn.click();
//
//        WaitUtils.waitForVisible(travellersdrop);
//
//        // Step 2: Adjust the adult count
//        adjustCount(aC, adultSectionElement, adultCountTextLocator);  // New locator for adult count text
//
//        // Step 3: Adjust the child count
//        adjustCount(cC, childSectionElement, childCountTextLocator);  // New locator for child count text
//
//        // Step 4: Adjust the infant count
//        adjustCount(iC, infantSectionElement, infantCountTextLocator);  // New locator for infant count text
//    }

//    private void adjustCount(int desiredCount, WebElement sectionElement, WebElement countTextLocator) {
//        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
//
//        // Wait for the section element to be clickable
//        wait.until(ExpectedConditions.elementToBeClickable(sectionElement));
//
//        // Set initial current count based on section type
//        int currentCount = 0;  // Default value
//
//        // Set current count according to the section (no need for getText)
//        if (sectionElement == adultSectionElement) {
//            currentCount = 1;  // Initial value for adult section
//        } else if (sectionElement == childSectionElement) {
//            currentCount = 0;  // Initial value for child section
//        } else if (sectionElement == infantSectionElement) {
//            currentCount = 0;  // Initial value for infant section
//        }
//
//        // Ensure we don't overshoot the desired count
//        while (currentCount < desiredCount) {
//            try {
//                // Click the increment button
//                WebElement incrementButton = sectionElement.findElement(By.xpath("//div[@class = 'qtyInc']"));
//                incrementButton.click();
//
//                // Wait for the count text to update after the click
//                wait.until(ExpectedConditions.textToBePresentInElementLocated(countTextLocator, String.valueOf(currentCount + 1)));
//
//                // Update currentCount to the new value (check the text again to avoid overshooting)
//                String countText = driver.findElement(countTextLocator).getText();
//                currentCount = Integer.parseInt(countText);
//
//                // If the count reaches the desired count, break the loop
//                if (currentCount >= desiredCount) {
//                    break;
//                }
//            } catch (StaleElementReferenceException e) {
//                // If element becomes stale, re-locate and retry
//                System.out.println("Stale element detected, re-locating...");
//                sectionElement = wait.until(ExpectedConditions.elementToBeClickable(sectionElement));  // Re-locate section element
//            }
//        }
//    }




//    public void selectTravellers(String adults) {
//       // wait.waitForClickable(travellersBtn).click();
////
////        int adultCount = Integer.parseInt(adults);
////        By addAdultBtn = By.xpath("//button[@aria-label='Increase adults']");
//
////        for (int i = 1; i < adultCount; i++) {
////            wait.waitForClickable(addAdultBtn).click();
////        }
//        System.out.println("Hey");
//    }

//public void selectTravellers(String adultCount, String childCount, String infantCount) {
//
//    int aC = Integer.parseInt(adultCount);
//    int cC = Integer.parseInt(childCount);
//    int iC= Integer.parseInt(infantCount);
//    // Step 1: Click on the travelers section to expand the dropdown
//    WaitUtils.waitForClickable(travellersBtn);
//    travellersBtn.click();
//
//    WaitUtils.waitForVisible(travellersdrop);
//    // Step 2: Adjust the adult count
//    adjustCount(aC, adultSectionElement);  // You will need the WebElement for the adult section
//
//    // Step 3: Adjust the child count
//    adjustCount(cC, childSectionElement);  // You will need the WebElement for the child section
//
//    // Step 4: Adjust the infant count
//    adjustCount(iC, infantSectionElement);  // You will need the WebElement for the infant section
//}
//
//    private void adjustCount(int desiredCount, WebElement sectionElement) {
//        // Wait for the section element to be clickable (if not already clicked)
//        WaitUtils.waitForClickable(sectionElement);
//
//        int currentCount = 0;  // Default value (adjust if you have a way to get the initial count)
//
//        // Get the current count displayed for the section
//        if (sectionElement == adultSectionElement) {
//            currentCount = 1;  // Set initial value for adult section
//        } else if (sectionElement == childSectionElement) {
//            currentCount = 0;  // Set initial value for child section
//        } else if (sectionElement == infantSectionElement) {
//            currentCount = 0;  // Set initial value for infant section
//        }
//
//        // If current count is less than the desired count, click "+" to increase
//        while (currentCount < desiredCount) {
//            // Find the increment button and click it
//            WebElement incrementButton = sectionElement.findElement(By.xpath("//div[@class = 'qtyInc']"));  // Adjust for actual button selector
//            incrementButton.click();
//            currentCount++; // Increment the count after clicking
//        }
//
////        // If current count is more than desired count, click "-" to decrease (optional, if needed)
////        while (currentCount > desiredCount) {
///          WebElement decrementButton = sectionElement.findElement(By.xpath("//*[@class, 'decreaseButton')]"));  // Adjust for actual button selector
////            decrementButton.click();
////            currentCount--; // Decrement the count after clicking
////        }
//    }

//public void selectTravellers(String adultCount, String childCount, String infantCount) {
//
//    int aC = Integer.parseInt(adultCount);
//    int cC = Integer.parseInt(childCount);
//    int iC = Integer.parseInt(infantCount);
//
//    // Step 1: Click on the travelers section to expand the dropdown
//    WaitUtils.waitForClickable(travellersBtn);
//    travellersBtn.click();
//
//    WaitUtils.waitForVisible(travellersdrop);
//
//    // Step 2: Adjust the adult count
//    adjustCount(aC, adultSectionElement);
//
//    // Step 3: Adjust the child count
//    adjustCount(cC, childSectionElement);
//
//    // Step 4: Adjust the infant count
//    adjustCount(iC, infantSectionElement);
//}
//
//    private void adjustCount(int desiredCount, WebElement sectionElement) {
//       // WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
//
//        // Wait for the section element to be clickable
//        WaitUtils.waitForVisible(sectionElement);
//       // wait.until(ExpectedConditions.elementToBeClickable(sectionElement));
//
//        int currentCount = 0;  // Default value (adjust if you have a way to get the initial count)
//
//        // Set initial current count based on section type
//        if (sectionElement == adultSectionElement) {
//            currentCount = 1;  // Initial value for adult section
//        } else if (sectionElement == childSectionElement) {
//            currentCount = 0;  // Initial value for child section
//        } else if (sectionElement == infantSectionElement) {
//            currentCount = 0;  // Initial value for infant section
//        }
//
//        // Adjust the count by clicking "+" button until we reach the desired count
//        while (currentCount < desiredCount) {
//            try {
//                // Re-locate the increment button each time (in case the element becomes stale)
//                WebElement incrementButton = sectionElement.findElement(By.xpath("//div[@class = 'qtyInc']"));
//                incrementButton.click();
//                currentCount++;  // Increment the count after clicking
//            } catch (StaleElementReferenceException e) {
//                // If the element becomes stale, re-locate the section element and retry
//                System.out.println("Stale element detected, re-locating...");
//                sectionElement = WaitUtils.waitForClickable(sectionElement);  // Re-locate section element
//            }
//        }
//    }


